#!/usr/bin/env dash
# Runs a full update and saves log files.
# Full update includes:
# - system packages with system package manager
# - cargo packages
# - go packages (installed via go-get)
# - pipx packages (python pkgs in their own venvs with entries in $PATH)
# - global pip3 packages (including pipx)
# - global npm packages
# - global luarocks
# - global rubygems
# - flatpaks
# - chromium (via chromium-latest-linux).
# Everything is run simultaneously in the background. The system update is also
# displayed in the interactive session via `tee` so I can enter my root pw and
# watch it happen.
# Log files can be big, so all but the most recent are compressed.
# TODO: Update neovim plugins
# TODO: use npx to contain npm packages
# TODO: determine number of cores and use it to run the max number of parallel
# processes.

###########
# Prepare #
###########

# Compress old logs and create directory for new logs #

script_dir="$HOME/Executables/shell-scripts/updates"
cd "$script_dir" || return 1
fd -t f -e sh -x chmod +x # So I can run the scripts with their shebangs
mkdir -p "$XDG_DATA_HOME/update-all/logs" "$GOPATH" && cd "$XDG_DATA_HOME/update-all/logs" || return 1
echo 'Compressing old logs'
fd -t d -x tar -I "lzip --best" -cf "{/}.tar.lz" "{}"
fd -t d -x rm -rf

time_start=$(date '+%s')
mkdir "$time_start"
cd "$time_start" || return 2
log_dir="$PWD"
# Use log_dir in below scripts.
export log_dir
echo # newline

###############
# Arg Parsing #
###############
if [ "$1" = '-lite' ] || [ "$1" = '--lite' ]; then
	export litemode=1
fi

if [ -z "$litemode" ]; then
	echo 'Running full upgrade, including compilation of large programs'
else
	echo 'Running lite upgrade, skipping compilation of large programs'
fi

#####################
# Logging functions #
#####################

# For both these functions, the input corresponds to a file in
# $script_dir with the ".sh" extension added.
# Each function logs output to $log_dir

# Adding "2>&1" and "< /dev/null" to nohup commands will
# hide nohup output message ("nohup: ignoring input and...")

# Run and log in background
log_bg() {
	echo "Starting update: $1"
	nohup "$script_dir/$1.sh" >"$log_dir/$1-$time_start.log" 2>&1 &
}

# Run and log in foreground (live-preview log file in interactive session)
# Done in foreground so I can enter my password (dnf) and because some things need
# a controlling tty for compilation.
log_fg() {
	echo && echo "Starting update: $1"
	"$script_dir/$1.sh" | tee "$log_dir/$1-$time_start.log"
}

###############
# Run updates #
###############

log_bg 'pip-pipx'              # see https://pipxproject.github.io/pipx/
log_bg 'rubygem-luarocks-node' # combine gem+luarocks+npm since they update quickly
log_bg 'program-data'          # have some programs sync their data
if [ -z "$litemode" ]; then
	log_bg 'go'     # build go packages installed with "go get"
	log_bg 'go-big' # same as above, but for larger packages (slow)
	log_bg 'cargo'  # rust packages (extremely cpu-heavy)
	log_bg 'kitty'  # compile kitty from git
fi

if [ "$MACHINE" = 'Linux' ]; then
	if [ -z "$litemode" ]; then
		log_bg 'newsboat'          # compile newsboat from git
		log_bg 'neovim'            # compile neovim from git
		log_bg 'small-cc-programs' # compile imv from git
		log_bg 'stack'             # haskell packages (infrequent updates, cpu-heavy, slow)
		log_bg 'in-containers'     # Updates running inside containers
	fi
	log_bg 'flatpak'  # repair and update user-installed flatpaks
	log_bg 'chromium' # tertiary browser (after Firefox Nightly, Falkon)
	log_fg 'dnf'      # system-wide update, autoremoval, and repo caching.

elif [ "$MACHINE" = 'Darwin' ]; then
	echo
	log_fg 'homebrew' # repo-caching and updating of homebrew formulae and casks

else
	echo 'Unsupported machine for system package updates'
	echo "Your machine is $MACHINE"
fi
# zpmod is best compiled in the foreground since it uses tcsetpgrp
log_fg 'zplugin' # update zplugin, its zsh plugins, and zpmod

# vim: filetype=sh
